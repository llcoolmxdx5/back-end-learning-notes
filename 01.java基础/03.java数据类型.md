# 数据类型

Java 语言支持的数据类型分为两种：基本数据类型（Primitive Type）和引用数据类型（Reference Type）。

## 基本数据类型

基本数据类型包括 boolean（布尔型）、float（单精度浮点型）、char（字符型）、byte（字节型）、short（短整型）、int（整型）、long（长整型）和 double （双精度浮点型）共 8 种

| 类型名称 | 关键字 | 占用内存 | 取值范围 |
| :--- | :--- | :--- | :--- |
| 字节型 | byte | 1 字节 | -128~127 |
| 短整型 | short | 2 字节 | -32768~32767 |
| 整型 | int | 4 字节 | -2147483648~2147483647 |
| 长整型 | long | 8 字节 | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float | 4 字节 | +/-3.4E+38F（6~7 个有效位） |
| 双精度浮点型 | double | 8 字节 | +/-1.8E+308 (15 个有效位） |
| 字符型 | char | 2 字节 | ISO 单一字符集 |
| 布尔型 | boolean | ? | true 或 false |

提示：char 代表字符型，实际上字符型也是一种整数类型，相当于无符号整数类型。

所有的基本数据类型的大小（所占用的字节数）都已明确规定，在各种不同的平台上保持不变，这一特性有助于提高 Java 程序的可移植性。

基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），下面分别介绍这 4 大类数据类型。

### 整数类型

Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。

具体说明
- 字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。
- 短整型（short）	short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。
- 整型（int）	int 类型是最常使用的一种整数类型。
- 长整型（long）	对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。

提示：因为 byte 类型、short 类型、int 类型和 long 类型都是整数类型，故可以使用“+”相加，而非字符串之间的连接

### 浮点类型

浮点类型是带有小数部分的数据类型，也叫实型。浮点型数据包括单精度浮点型（float）和双精度浮点型（double），代表有小数精度要求的数字。

单精度浮点型（float）和双精度浮点型（double）之间的区别主要是所占用的内存大小不同，float 类型占用 4 字节的内存空间，double 类型占用 8 字节的内存空间。双精度类型 double 比单精度类型 float 具有更高的精度和更大的表示范围。

Java 默认的浮点型为 double，例如，11.11 和 1.2345 都是 double 型数值。如果要说明一个 float 类型数值，就需要在其后追加字母 f 或 F，如 11.11f 和 1.2345F 都是 float 类型的常数。

注意：一个值要能被真正看作 float，它必须以 f（或 F）后缀结束；否则，会被当作 double 值。对 double 值来说，d（或 D）后缀是可选的。

### 布尔类型

布尔类型（boolean）用于对两个数值通过逻辑运算，判断结果是“真”还是“假”。Java 中用保留字 true 和 false 来代表逻辑运算中的“真”和“假”。因此，一个 boolean 类型的变量或表达式只能是取 true 和 false 这两个值中的一个。

在 Java 语言中，布尔类型的值不能转换成任何数据类型，true 常量不等于 1，而 false 常量也不等于 0。这两个值只能赋给声明为 boolean 类型的变量，或者用于布尔运算表达式中。

Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。

### 字符类型

Java 语言中的字符类型（char）使用两个字节的 Unicode 编码表示，它支持世界上所有语言，可以使用单引号字符或者整数对 char 型赋值。

提示：字符通常用 16 进制表示，范围从“\uOOOO”~“\uFFFF”，即从 0~65535。\uOOOO 和 \uFFFF 中的 u 告诉编译器是用两个字节（16 位）字符信息表示一个 Unicode 字符。

```java
// 单引号
char c1 = 'A';
// 双引号 String 是引用类型
String s1 = "A"
```

## 引用数据类型

引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。

引用类型还有一种特殊的 null 类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是 Java 语言里不再使用指针这个说法。

空类型（null type）就是 null 值的类型，这种类型没有名称。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。

空引用（null）是 null 类型变量唯一的值。空引用（null）可以转换为任何引用类型。

在实际开发中，程序员可以忽略 null 类型，假定 null 只是引用类型的一个特殊直接量。

注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。

### String 字符串

Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。

```java
String s = "hello";
String t = s;
s = "world";
System.out.println(t); // t 是"hello"还是"world"?
// hello
```

当程序第一次使用某个字符串直接量时，Java 会使用常量池（constant pool）来缓存该字符串直接量，如果程序后面的部分需要用到该字符串直接量时，Java 会直接使用常量池（constantpool）中的字符串直接量。

常量池（constant pool）指的是在编译期被确定，并被保存在已编译的 .class 文件中的一些数据，它包括关于类、方法、接口中的常量，也包括字符串直接量。

```java
String s0 = "hello";
String s1 = "hello";
String s2 = "he" + "llo";
System.out.println(s0 == s1); // true
System.out.println(s0 == s2); // true
// 因为常量池中只有一个 hello
```

### 数组类型

定义一个数组类型的变量，使用数组类型"类型[\]"，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用 `new int[5]` 表示创建一个可容纳5个 `int` 元素的数组

Java的数组有几个特点：

- 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；
- 数组一旦创建后，大小就不可改变。

要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。

可以修改数组中的某一个元素，使用赋值语句

可以用数组变量.length获取数组大小

数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错

也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。 `int[] ns = new int[] { 68, 79, 91, 85, 62 };` 还可以进一步简写为： `int[] ns = { 68, 79, 91, 85, 62 };`

## var关键字

有些时候，类型的名字太长，写起来比较麻烦。这个时候，如果想省略变量类型，可以使用var关键字：`var sb = new StringBuilder();` 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句实际上会自动变成 `StringBuilder sb = new StringBuilder();`

因此，使用var定义变量，仅仅是少写了变量类型而已。

## 类型隐式转换（自动类型转换）

如果以下 2 个条件都满足，那么将一种类型的数据赋给另外一种类型变量的时，将执行自动类型转换（automatic type conversion）。
- 两种数据类型彼此兼容
- 目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）

当以上 2 个条件都满足时，拓宽转换（widening conversion）发生。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。

在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下：
- 数值型数据的转换：byte→short→int→long→float→double。
- 字符型转换为整型：char→int。

以上数据类型的转换遵循从左到右的转换顺序，最终转换成表达式中表示范围最大的变量的数据类型。

注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。

```java
char a = 'A';
System.out.println(+a); // 65 
```

## 类型显式转换（强制类型转换）

所以当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。其语法格式如下：`(type)variableName`

```java
int a = 3;
double b = 5.0;
a = (int)b;
```

在强制类型转换中，如果是将浮点类型的值转换为整数，直接去掉小数点后边的所有数字；而如果是整数类型强制转换为浮点类型时，将在小数点后面补零。

```java
int a = 65;
System.out.println((char)a); // 'A' 
```
